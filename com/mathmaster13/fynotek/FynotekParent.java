package com.mathmaster13.fynotek;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 A class for handling words in Fynotek, a conlang by mochaspen, in both its modern and old form. The parent class of <code>FynotekWord</code> and <code>OldFynotekWord</code>, containing all shared code between the two.
 @author mathmaster13
 @since 1.0
 */
public abstract sealed class FynotekParent permits FynotekWord, OldFynotekWord {
    /** The part of a Fynotek word before its final vowel or diphthong.
     @see #FynotekParent(String, Ablaut)
     */
    @NotNull
    public final String beginning;
    /** A Fynotek word's final vowel or diphthong.
     @see #FynotekParent(String, Ablaut)
     @see #ablaut(Ablaut)
     */
    @NotNull
    public final String vowels;
    /** The part of a Fynotek word after its final vowel or diphthong.
     @see #FynotekParent(String, Ablaut)
     */
    @NotNull
    public final String end;
    /** The vowel that a Fynotek word was marked with through ablaut. A non-marked word uses the value <code>'\u0000'</code>, and a word marked by reduplication ablaut uses <code>'r'</code>. This field should not be modified by a programmer unless they make a different implementation of the <code>match</code> method.
     @see #isMarked()
     @see #match(FynotekParent)
     @see #ablaut(Ablaut)
     */
    @NotNull
    protected final Ablaut ablaut; // This class expects you to only create objects from root words, not marked forms. Create marked words with nounCase(), verbTense(), or match(), and the method will mark the word as such.

    // Constants
    private static final char[] vowelList = { 'a', 'e', 'i', 'o', 'u', 'y' };
    /** A list of all stops in Fynotek, in its modern or old form. Used internally in <code>isValidSequence</code>.
     @see #isValidSequence(String, String, byte, boolean)
     */
    protected static final char[] stopList = { 'p', 't', 'k', '\'' };

    /**
     Returns a String representation of this word.
     @return String representation of this word.
     */
    @Override
    public @NotNull String toString() {
        return (beginning + vowels + end);
    }

    /** Generated by IntelliJ IDEA Community. */
    @Override
    public boolean equals(@Nullable Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        FynotekParent that = (FynotekParent) o;

        if (!beginning.equals(that.beginning)) return false;
        if (!vowels.equals(that.vowels)) return false;
        if (!end.equals(that.end)) return false;
        return ablaut == that.ablaut;
    }

    /** Generated by IntelliJ IDEA Community. */
    @Override
    public int hashCode() {
        int result = beginning.hashCode();
        result = 31 * result + vowels.hashCode();
        result = 31 * result + end.hashCode();
        result = 31 * result + ablaut.hashCode();
        return result;
    }

    // Public constructors
    /**
     Converts a String into a FynotekParent. Leading and trailing whitespace is ignored (the <code>String.trim()</code> method is called on <code>word</code>).
     @param word word to be converted to a FynotekParent.
     */
    public FynotekParent(String word) {
        this(word, Ablaut.NONE);
    }

    // Private constructors
    /**
     Creates a FynotekParent and sets its parameters to those provided.
     @param beginning the part of a word before its final vowel or diphthong.
     @param vowels a word's final vowel or diphthong.
     @param end the part of a word after its final vowel or diphthong.
     @param ablaut the character to set <code>markVowel</code> to.
     @see #beginning
     @see #vowels
     @see #end
     @see #ablaut
     */
    protected FynotekParent(@NotNull String beginning, @NotNull String vowels, @NotNull String end, @NotNull Ablaut ablaut) {
        this.beginning = beginning;
        this.vowels = vowels;
        this.end = end;
        this.ablaut = ablaut;
    }

    /**
     Creates a new FynotekParent from an existing FynotekParent.
     @param word the word to be copied to the new FynotekParent.
     */
    protected FynotekParent(@NotNull FynotekParent word) {
        beginning = word.beginning;
        vowels = word.vowels;
        end = word.end;
        ablaut = word.ablaut;
    }

    /**
     Converts a String into a FynotekParent, and marks the word as having the specified ablaut.  Leading and trailing whitespace is ignored (the <code>String.trim()</code> method is called on <code>word</code>), and the word will always be converted to lowercase.
     @param word word to be converted to a FynotekParent.
     @param ablaut the type of ablaut this word has.
     */
    protected FynotekParent(@NotNull String word, @NotNull Ablaut ablaut) {
        word = word.trim().toLowerCase(); // TODO: Change implementation to preserve capitalization (maybe?)
        this.ablaut = ablaut;
        if (word.isEmpty()) { // If you want to re-add the null check, change the condition to (word == null || word.isEmpty())
            beginning = vowels = end = "";
        } else if (word.length() == 1) {
            if (isVowel(word.charAt(0))) {
                vowels = word;
                beginning = end = "";
            } else {
                end = word;
                beginning = vowels = "";
            }
        } else {
            int vowelIndex = 0;
            int vowelLength = 0;
            for (int i = word.length() - 1; i >= 0; i--) {
                if (isVowel(word.charAt(i))) {
                    if (isVowel(word.charAt(i - 1))) {
                        vowelIndex = i - 1;
                        vowelLength = 2;
                    } else {
                        vowelIndex = i;
                        vowelLength = 1;
                    }
                    break;
                }
            }
            beginning = word.substring(0, vowelIndex);
            vowels = word.substring(vowelIndex, vowelIndex + vowelLength);
            end = word.substring(vowelIndex + vowelLength);
        }
    }

    // Internal-use methods
    /**
     Marks this word with the specified ablaut.
     @param vowel the ablaut to mark the word as.
     @return this word marked with the specified ablaut.
     @see #ablaut
     */
    protected abstract @NotNull FynotekParent ablaut(@NotNull Ablaut vowel);

    /**
     Checks if a given character is a vowel. Specifically,returns <code>true</code> if and only if the given character is <code>'a'</code>, <code>'e'</code>, <code>'i'</code>, <code>'o'</code>, <code>'u'</code>, or <code>'y'</code>.
     @param letter the character to be checked for whether it is a vowel or not.
     @return <code>true</code> if and only if <code>letter</code> is a vowel.
     */
    protected static boolean isVowel(char letter) {
        for (char i : vowelList) if (letter == i) return true;
        return false;
    }

    private static boolean isStop_internal(char letter) {
        for (char i : stopList) {
            if (letter == i)
                return true;
        }
        return false;
    }

    /**
     A back-end for the <code>isValidSequence</code> functions in this class' subclasses. As such, implementation details will not be provided.
     @return <code>true</code> if <code>sequence</code> is a valid sequence, and <code>false</code> if not.
     @see OldFynotekWord#isValidSequence(String)
     @see FynotekWord#isValidSequence(String)
     */
    protected static boolean isValidSequence(@NotNull String sequence, @NotNull String regex, byte maxConsonants, boolean checkForSameConsonants) { // If stuff goes wrong try changing the byte to an int. Also, !checkForSameConsonants is used to check for if you should apply the special end cases for consonants.
        sequence = sequence.toLowerCase().trim();
        // Blank string check
        if (sequence.isEmpty())
            return false;

        // Orthographic validity check
        if (!sequence.replaceAll(regex, "").isEmpty())
            return false;

        // Check for a multiple-word sequence
        final String[] wordArray = sequence.split("\\s+");
        if (wordArray.length == 0)
            return false;
        if (wordArray.length > 1) {
            boolean output = true;
            for (String j : wordArray)
                output = (isValidSequence(j, regex, maxConsonants, checkForSameConsonants) && output);
            return output;
        }

        // Phonotactic vallidity check
        int i = 0;
        while (i < sequence.length()) {
            char testChar = sequence.charAt(i);
            if (isVowel(testChar)) {
                if (i > sequence.length() - 3)
                    return true; // If we get to this point, no VVV can occur.
                // VVV check
                int j;
                for (j = i + 1; j < sequence.length(); j++)
                    if (!isVowel(sequence.charAt(j)))
                        break;
                if (j - i > 2)
                    return false;
                i = j;

            } else {
                // Consonant check
                int j;
                for (j = i + 1; j < sequence.length(); j++)
                    if (isVowel(sequence.charAt(j)))
                        break;
                if (j - i + (!checkForSameConsonants && (i == 0 || j == sequence.length()) ? 1 : 0) > maxConsonants)
                    return false;

                // Same character check, if applicable
                if (checkForSameConsonants) {
                    char checkForSameChar = testChar;
                    for (int k = i + 1; k < j; k++) {
                        char c = sequence.charAt(k);
                        if (c == checkForSameChar)
                            return false;
                        checkForSameChar = c;
                    }
                }

                // Stop+Stop check
                boolean stopCheck = isStop_internal(testChar);
                for (int l = i + 1; l < j; l++) {
                    boolean currentCharIsStop = isStop_internal(sequence.charAt(l));
                    if (stopCheck && currentCharIsStop)
                        return false;
                    stopCheck = currentCharIsStop;
                }

                i = j;
            }
        }
        return true;
    }

    // Public methods
    /**
     Returns this FynotekParent inflected for the verb tense specified by <code>tenseOfVerb</code>. It is likely to be necessary to override this implementation if a programmer extends this class.
     @param tense  the verb tense to inflect this FynotekParent for.
     @return this FynotekParent inflected for the specified verb tense.
     @see #match(FynotekParent)
     */
    public @NotNull FynotekParent verbTense(@NotNull Tense tense) {
        return ablaut(tense.ablaut);
    }

    /**
     Returns this FynotekParent inflected for the same case or tense as <code>word</code>. It is recommended to override this implementation if a programmer extends this class.
     @param word the FynotekParent to match this word's inflection with.
     @return this FynotekParent inflected for the same case or tense as <code>word</code>.
     @see #verbTense(Tense)
     */
    public @NotNull FynotekParent match(@NotNull FynotekParent word) {
        return ablaut(word.ablaut);
    }

    /**
     Returns whether this FynotekParent is marked or not. Specifically, returns <code>(markVowel != '\u0000')</code>. <b>Be careful:</b> this means that non-hypothetical present-tense verbs will return <code>false</code>, and in <code>FynotekWord</code> specifically nominative-case nouns will also return <code>false</code>, and "folo" in the accusative case (if "folo" is not a proper noun) will return <code>true</code>.
     @return <code>true</code> if this FynotekParent has been marked by ablaut or a proper noun suffix, and <code>false</code> if it has not been.
     @see #ablaut
     */
    public final boolean isMarked() {
        return (ablaut != Ablaut.NONE);
    }

    /**
     Returns this word with a suffix added to mark the first, second, or third person.
     @param person the person to mark this word for.
     @return this word with a suffix added to mark the first, second, or third person.
     @see #verbTense(Tense)
     */
    public @NotNull abstract FynotekParent personSuffix(Person person);

    /**
     * Represents
     */
    protected enum Ablaut {
        NONE('\u0000', '\u0000'), A('a', 'e'), E('e', 'a'), I('i', 'y'), Y('y', 'i'),
        O_NOUN('o', 'u'), O_VERB('o', 'u'), U('u', 'o'), REDUPLICATION('\u0000', '\u0000');

        protected final char asChar;
        protected final char ablautPair;

        Ablaut(char asChar, char ablautPair) {
            this.asChar = asChar;
            this.ablautPair = ablautPair;
        }
    }

    /**
     * Represents the tense of a Fynotek verb. Tenses prefixed with <code>HYP_</code> are hypothetical tenses.
     */
    public enum Tense {
        PRESENT(Ablaut.NONE), PAST(Ablaut.I), FUTURE(Ablaut.O_VERB), GNOMIC(Ablaut.Y), // gets converted to HYP_GNOMIC in old fynotek
        HYP_PRESENT(Ablaut.A), HYP_PAST(Ablaut.E), HYP_FUTURE(Ablaut.U), HYP_GNOMIC(Ablaut.REDUPLICATION);

        @NotNull
        protected final Ablaut ablaut;

        Tense(@NotNull Ablaut ablaut) {
            this.ablaut = ablaut;
        }
    }

    /**
     * Represents the concept of person on a Fynotek verb.
     * @see #personSuffix(Person)
     */
    public enum Person {
        P1(null), P2("a"), P3("o");

        @Nullable
        protected final String suffix;

        Person(@Nullable String suffix) {
            this.suffix = suffix;
        }
    }
}